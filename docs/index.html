<!DOCTYPE html>
    <html lang=en>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        
        <title>Synapse</title>
        
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="css/prettify.css">
        <link rel="stylesheet" href="css/bootstrap.css">
        <link rel="stylesheet" href="css/style.css">
        
        <script>
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-8483912-3']);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
    </head>
    <body>

        <header class="topbar">
            <div class="topbar-inner">
                <div class="container-fluid">
                    <span class="brand">Synapse <span style="font-size: 15px; color: #999">0.3.2</span></span>
                    <ul>
                        <li><a href="https://github.com/bruth/synapse/">GitHub Repository</a>
                        <li><a href="http://jsfiddle.net/bruth/bufeK/">jsFiddle Demo</a>
                    </ul>
                </div>
            </div>
        </header>

        <nav id=sidebar>
            <h3>Get Started</h3>
            <ul class=unstyled>
                <li><a href=#dependencies>Dependencies</a>
                <li><a href=#download>Download</a>
                <li><a href=#umd>UMD</a>
             </ul>

            <h3>Learn</h3>
            <ul class=unstyled>
                <li><a href=#background>Background</a>
                <li><a href=#channels>Channels</a>
                <li><a href=#interfaces>Interfaces</a>
            </ul>

            <h3>APIs</h3>
            <ul class=unstyled>
                <li><a href=#constructor-api>Constructor API</a>
                <li><a href=#object-api>Object API</a>
                    <ul>
                        <li><a href=#object-api-properties>Properties</a>
                        <li><a href=#object-api-channel>Channel Methods</a>
                        <li><a href=#object-api-channel-configuration>Channel Configuration</a>
                        <li><a href=#object-api-channel-flow>Channel Flow Methods</a>
                        <li><a href=#object-api-interface>Interface Methods</a>
                    </ul>
                <li><a href=#hooks>Hook API</a>
                    <ul>
                        <li><a href=#hooks-base>Base</a>
                        <li><a href=#hooks-interfaces>Interfaces</a>
                        <li><a href=#hooks-events>Events</a>
                        <li><a href=#hooks-helpers>Helpers</a>
                    </ul>
            </ul>

            <h3>Supported Hooks</h3>
            <ul class=unstyled>
                <li><a href=#plain-objects>Plain Objects</a>
                <li><a href=#jquery>jQuery</a>
                    <ul>
                        <li><a href=#jquery-simple-interfaces>Simple Interfaces</a>
                        <li><a href=#jquery-compound-interfaces>Compound Interfaces</a>
                    </ul>
                <li><a href=#zepto>Zepto</a>
                <li><a href=#backbone-view>Backbone View</a>
                <li><a href=#backbone-model>Backbone Model</a>
            </ul>
        </nav>

        <div id="content">

            <h1>Synapse - Data Binding For The Rest Of Us</h1>

            <section class="span16">
                <p class="alert-message">
                <span class="label warning">BETA</span> These docs are missing some significant parts. Please
                be patient while they are being updated.</p>
            </section>

            <h3 id=dependencies>Dependencies</h3>

            <section class=row>
                <span class=span16>
                    <p>None</p>
                </span>
            </section>

            <h3 id=download>Download</h3>

            <section class=row>
                <span class=span16>
                    <p><em>Right-click and save-as</em></p>
                    <ul>
                        <li><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/dev/synapse.js>Development Version (0.3.2)</a> - 13K
                        <li><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/min/synapse.js>Production Version (0.3.2)</a> - 1.7K minified, gzipped
                    </ul>

                    <table>
                        <thead>
                            <tr>
                                <th>Hook Name</th>
                                <th>Development</th>
                                <th>Production</th>
                                <th>Dependencies</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Object
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/dev/synapse/hooks/object.js>Download</a>
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/min/synapse/hooks/object.js>Download</a>
                                <td>(none)
                            </tr>
                            <tr>
                                <td>jQuery
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/dev/synapse/hooks/jquery.js>Download</a>
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/min/synapse/hooks/jquery.js>Download</a>
                                <td>jQuery
                            </tr>
                            <tr>
                                <td>Zepto
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/dev/synapse/hooks/zepto.js>Download</a>
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/min/synapse/hooks/zepto.js>Download</a>
                                <td>Zepto
                            </tr>
                            <tr>
                                <td>Backbone Model
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/dev/synapse/hooks/backbone-model.js>Download</a>
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/min/synapse/hooks/backbone-model.js>Download</a>
                                <td>Backbone
                            </tr>
                            <tr>
                                <td>Backbone View
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/dev/synapse/hooks/backbone-view.js>Download</a>
                                <td><a href=https://raw.github.com/bruth/synapse/0.3.2/dist/min/synapse/hooks/backbone-view.js>Download</a>
                                <td>Backbone
                            </tr>
                        </tbody>
                    </table>

                </span>
            </section>

            <h3 id=umd>Universal Module Definition (UMD)</h3>

            <section class="row">
                <span class="span16">
                    <p>Synapse supports the <a href=https://github.com/umdjs/umd>UMD</a>. It
                    can load in the CommonJS/Node environment, via AMD in the browser or as
                    a traditional script.</p>
                </span> 
            </section>

            <h3 id="background">Background</h3>

            <section class="row">
                <span class="span16">
                    <p>Synapse is a JavaScript data binding library. The API was written
                    to work <strong>all-in-code</strong>, that is, it does not depend on
                    any template library or special attributes (e.g. <code>data-bind</code>)
                    to work. The focus has been placed into defining the minimal components
                    necessary to enable data binding to work across various objects.</p>
                    
                    <p>Fundamentally, there are two parties involved: <strong>subjects</strong>
                    and <strong>observers</strong>. Keep the following in mind.</p>
                    
                    <p>Any object can be an observer. It simply waits until the subject's state
                    changes and then does something with that information. In the context of data
                    binding, it typically records that change in state in some way or performs an
                    action as a result of the change.</p>

                    <p>Subjects on the other hand must have a mechanism for being aware of actions
                    or events that are performed on itself. In the case of the DOM, when a user
                    clicks a button, the <code>onclick</code> event is triggered on that DOM
                    element. These actions can cause a cascade of events all of which can be used
                    to respond to the state changes.</p>
                </span>
            </section>

            <h3 id=channels>Channels</h3>

            <section class="row">
                <span class="span5">
                    <p>Synapse provides a mechanism for defining a communication channel
                    between two objects. In order for two objects to communicate, there
                    are three components needing to be defined for <code>A</code>
                    &rarr; <code>B</code>:</p>
                    <ol>
                        <li>The event that will trigger when <code>A</code>'s state changes
                        <li>The function to call on/for <code>A</code> that returns a
                        representation of the changed state (typically the data that has
                        changed)
                        <li>The function to call on/for <code>B</code> that handles this
                        received data from <code>A</code>
                    </ol>
                    <p>The channel can be defined with respect to either the subject A or
                    the observer B depending on the system. In either case, whenever a change
                    in state occurs in A, B (and all other observers of that event) will be
                    notified.</p>
                </span> 
                <span class="span11">

<pre id="ex1">
<input type=text value="Hello World!"> <span></span>
</pre>

<pre class="prettyprint linenums">
var A = $('input'),
    B = $('span');

A.bind('keyup', function() {
    B.text(A.val());
});

// Synapse abstracts away the need to write this spaghetti
// code. The following are equivalent
Synapse(A).notify(B);
Synapse(B).observe(A);
</pre>
                </span>
            </section>

            <h3 id=interfaces>Interfaces</h3>

            <section class="row">
                <span class="span5">
                    <p>The above examples explain the most simple interactions between two
                    objects. But how is data returned from or sent to each object if they
                    are of different types?</p>

                    <p>Synapse interfaces provide a way to generically get and set properties
                    on supported objects. A Synapse object has <code>get</code> and
                    <code>set</code> methods which allow for a consistent API regardless of the
                    underlying object type.</p>
                </span> 
                <span class="span11">

<pre class="prettyprint linenums">
// Use Synapse as a constructor exposes the interface
// methods. We are using the jQuery hook here to detect
// the type passed in (a CSS selector).
var A = new Synapse('input'),
    B = new Synapse('span');

// These 'interfaces' map to jQuery methods on the
// object, $.fn.val() and $.fn.text()
A.get('value'); // 'hello world'
B.set('text', A.get('value'));
B.get('text'); // 'hello world'
</pre>
                </span>
            </section>


            <h3 id="constructor-api">Constructor API</h3>

            <section class="row">
                <span class="span5">
                    <p><code>Synapse</code> can be used as a constructor or a
                    function. Using it as a <strong>constructor</strong> <em>wraps</em>
                    the object and exposes the full <code>Synapse</code> Object API. Using it
                    as a <strong>function</strong> will <em>augment</em> the passed in
                    <code>object</code> with a limited API.
                    </p>
                </span> 

                <span class="span11">
<pre class="prettyprint linenums">
var object = $('input');
var wrapped = new Synapse(object);
Synapse(object);
</pre>
                </span>
            </section>

            <h3 id=object-api>Object API</h3>

            <section class=row>
                <span class=span16>
                    <p>There two primary sets of methods, those that creates a
                    channel between two objects and those that control the
                    channel <em>flow</em>.</p>
                </span>
            </section>

            <h5 id=object-api-properties>Properties</h5>

            <section class=row>
                <span class=span5>
                    <ul>
                        <li><code>raw</code> - a reference to the original object.
                        <em>Note, if the hook this object is used with has a
                        <code>coerceObject</code> method defined, <code>raw</code>
                        will be the object that is returned from that function.</em>
                    </ul>
                </span>

                <span class=span11>
<pre class="prettyprint linenums">
wrapped.raw; // reference to `object`
</pre>
                </span>
            </section>

            <h5 id=object-api-channel>Channel Methods
                <span class="label notice">limited api</span></h5>

            <section class=row>
                <span class=span5>
                    <ul>
                        <li><code>observe</code> - opens a one-way channel between this
                        object and a subject where this object <em>observes</em> state changes
                        of the subject.

                        <li><code>notify</code> - opens a one-way channel between this object
                        and an observer where this object <em>notifies</em> it's state
                        changes to the observer. 

                        <li><code>sync</code> - opens a two-way channel between this object
                        and another where each acts as a subject and observer.
                    </ul>
                </span>
                <span class="span11">
<pre class="prettyprint linenums">
wrapped.observe(subject, [options]);
wrapped.notify(observer, [options]);
wrapped.sync(other, [options]);
</pre>

                </span>
            </section>

            <h5 id=object-api-channel-configuration>Channel Configuration</h5>

            <section class=row>
                <span class=span5>
                    <ul>
                        <li><code>event</code> - the event that will trigger the
                        subject to push it's interface value to all observers. this
                        is variable across hooks. this is optional only if the
                        subject's hook has a <code>detectEvent</code> method and
                        can be successfully detected.

                        <li><code>subjectInterface</code> - the interface identifier
                        of the subject for a given channel. this is variable across hooks.
                        this is optional only if the subject's hook has a
                        <code>detectInterface</code> method or the observer's hook has a
                        <code>detectOtherInterface</code> method and can be successfully
                        detected.

                        <li><code>observerInterface</code> - the interface identifier
                        of the observer for a given channel. this is variable across hooks.
                        this is optional only if the observer's hook has a
                        <code>detectInterface</code> method or the subject's hook has a
                        <code>detectOtherInterface</code> method and can be successfully
                        detected.

                        <li><code>converter</code> - an optional function or method name on
                        the observer that will take the value(s) provided by the subject and
                        return a value prior to calling <code>observer.set(...)</code>.

                        <li><code>triggerOnBind</code> - if set to true, when the channel is
                        initially created the subject will be triggered using the event
                        supplied or detected.
                    </ul>
                </span>
                <span class="span11">
<pre class="prettyprint linenums">
// available configuration options and their defaults
var options = {
    event: null,
    subjectInterface: null,
    observerInterface: null,
    converter: null,
    triggerOnBind: true
};

// the default, pass in a configuration options object defining
// any or all of the options
wrapped.observe(subject, [options]);

// shorthand method signatures

// no options passed, all `null` options will attempt to be detected
wrapped.observe(subject);

// define the observer and subject interfaces
wrapped.observe(subject, [subjectInterface], [observerInterface]);

// define just a converter
wrapped.observe(subject, [converter]);

</pre>

                </span>
            </section>

            <h5 id=object-api-channel-flow>Channel Flow Methods
                <span class="label notice">limited api</span></h5>

            <section class=row>
                <span class=span5>
                    <ul>
                        <li><code>stopObserving</code> - stops an object from observing all objects
                        it is currently observing and removes all event handlers referencing this
                        object. if a <code>Synapse</code> object is passed, only observing of that
                        object will be stopped.

                        <li><code>pauseObserving</code> - same as <code>stopObserving</code> except
                        event handlers are retained to allow for resuming observing. if a
                        <code>Synapse</code> object is passed, only observing of that object will
                        be paused.

                        <li><code>resumeObserving</code> - all paused obversing is resumed.
                        if a <code>Synapse</code> object is passed, only observing of that
                        object will be resumed.

                        <li><code>stopNotifying</code> - stops an object from notifying all objects
                        it is currently notifying and removes all event handlers referencing those
                        object. if a <code>Synapse</code> object is passed, only notifying of that
                        object will be stopped.

                        <li><code>pauseNotifying</code> - same as <code>stopNotifying</code> except
                        event handlers are retained to allow for resuming notifying. if a
                        <code>Synapse</code> object is passed, only notifying of that object will
                        be paused.

                        <li><code>resumeNotifying</code> - all paused notifying  is resumed. if an
                        existing <code>Synapse</code> is object passed, only notifying of that object
                        will be resumed.
                    </ul>

                </span> 
                <span class="span11">
<pre class="prettyprint linenums">
wrapped.stopObserving([other]);
wrapped.pauseObserving([other]);
wrapped.resumeObserving([other]);
wrapped.stopNotifying([other]);
wrapped.pauseNotifying([other]);
wrapped.resumeNotifying([other]);
</pre>
                </span>
            </section>

            <h5 id=object-api-interface>Interface Methods</h5>

            <section class=row>
                <span class=span5>
                    <ul>
                        <li><code>get</code> -  given an interface identifier,
                        return a representation of this subject's change in state.
                        <li><code>set</code> -  given an interface identifier and
                        a value provided by the subject, <em>sets</em> the value.
                    </ul>
                </span>

                <span class=span11>
<pre class="prettyprint linenums">
wrapped.get(interface);
wrapped.set(interface, value);
</pre>
                </span>
            </section>

            <h3 id=hooks>Hook API</h3>

            <section class="row">
                <span class="span16">
                    <p>Synapse relies on <strong>hooks</strong> being defined to
                    perform the <em>under-the-hood</em> operations. The Synapse
                    constructor is simply an abstraction for these hooks which are
                    defined on a per-object-type basis. Depending on the specificity
                    of the type, objects can <em>fallback</em> to less specific hooks
                    to have at least minimal functionality.</p>
                </span>
            </section>

            <h5 id=hooks-base>Base</h5>

            <section class="row">
                <span class="span5">
                    <p>A hook is simply an object. To make it distributable, it is recommended
                    to define it as a standalone module. The base parts of a hook include.</p>
                    <ul>
                        <li><code>typeName</code> - name of the object type this hook
                        represents
                        <li><code>checkObjectType</code> - a method which checks if the
                        object is applicable for this hook
                    </ul>
                </span>
                <span class=span11>
<pre class="prettyprint linenums">
define('awesome-hook', function() {
    return {
        // the name of the type this hook represents
        typeName: 'The Awesome Type',

        // checks whether the object is the correct type for this hook
        checkObjectType: function(object) {},
</pre>
                </span>
            </section>

            <h5 id=hooks-interfaces>Interfaces</h5>

            <section class=row>
                <span class=span5>
                    <p>The following methods are required for an object to an observer.</p>
                    <ul>
                        <li><code>getHandler</code> - a method which takes an object
                        and an interface identifier and returns a value
                        <li><code>setHandler</code> - a method which takes an object,
                        an interface identifier, and a value and sets the value
                    </ul>
                </span>

                <span class=span11>
<pre class="prettyprint linenums">
        ...
        // takes an object and a interface identifier and returns a value
        getHandler: function(object, interface) {},

        // takes an object, inteface identifier and value and sets the value
        setHandler: function(object, interface, value) {},
        ...
</pre>
                </span>
            </section>

            <h5 id=hooks-events>Events</h5>

            <section class=row>
                <span class=span5>
                    <p>The following methods are required for an object to a subject.</p>
                    <ul>
                        <li><code>onEventHandler</code> - a method which attaches an
                        event handler to an object
                        <li><code>offEventHandler</code> - a method which detaches an
                        event handler from an object
                        <li><code>triggerEventHandler</code> - a method which triggers
                        and event on an object
                    </ul>
                </span>

                <span class=span11>
<pre class="prettyprint linenums">
        ...
        // takes an object, event and handler and attaches the handler
        onEventHandler: function(object, event, handler) {},

        // take an object, event and handler and detaches the handler
        offEventHandler: function(object, event, handler) {},

        // takes an object and triggers an event on it
        triggerEventHandler: function(object, event) {},
        ...
</pre>
                </span>
            </section>

            <h5 id=hooks-helpers>Helpers</h5>

            <section class=row>
                <span class=span5>
                    <p>The following methods are optional, but can be very useful.</p>
                    <ul>
                        <li><code>coerceObject</code> - takes the raw object passed in
                        to <code>Synapse</code> and coerces the object into a more
                        useful object (think CSS selector &rarr; jQuery object)
                        <li><code>detectEvent</code> - (subjects only) detects an
                        appropriate event for the given object which will trigger the
                        downstream notification to observers
                        <li><code>detectInterface</code> - detects an appropriate interface
                        for the given object
                        <li><code>detectOtherInterface</code> - detects an appropriate
                        interface for the other object involved (either subject or observer)
                        <li><code>detectEvent</code> - (subjects only) detects an
                        appropriate event for the given object which will trigger the
                        downstream notification to observers
                    </ul>
                </span> 
                <span class="span11">
<pre class="prettyprint linenums">
        // takes the raw object passed in to Synapse and coerces the object into
        // a more useful object (think CSS selector --> jQuery object)
        coerceObject: function(object) {},

        // detects an appropriate interface for the given object
        detectInterface: function(object) {},

        // detects an appropriate interface for the other object involved (either
        // subject or observer)
        detectOtherInterface: function(object) {},

        // detects an appropriate event for the given object which will trigger
        // the downstream notification to observers
        detectEvent: function(object, [interface]) {}
    };
});
</pre>
                </span>
            </section>


            <h3 id=plain-objects>Plain Objects</h3>

            <section class=row>
                <span class=span16>
                    <p><strong>Supported Type.</strong> Plain objects are typically just
                    object primitives, e.g. <code>{}</code>, or objects created from the
                    <code>Object</code> constructor, e.g. <code>new Object()</code>.</p>

                    <p><strong>Events.</strong> These objects are assumed to <em>not</em> have
                    support for events and thus can only be observers. As a result, using this
                    hook alone is pretty useless since it has nothing to observe.. it is a lonely
                    object.</p>

                    <p><strong>Interfaces.</strong> The interfaces available for plain objects
                    are simply, their properties and methods. Methods always take precedence over
                    properties.</p>
                </span>

            </section>

            <h3 id=jquery>jQuery</h3>

            <section class=row>
                <span class=span16>
                    <p><strong>Supported Type.</strong> jQuery objects, CSS selectors,
                    and DOM elements.</p>

                    <p><strong>Events.</strong> DOM events via jQuery's <code>on</code>,
                    <code>off</code>, and <code>trigger</code> methods</p>

                    <p><strong>Interfaces.</strong> jQuery provides a very nice
                    API which encapsulates cross-browser inconsistencies with a
                    few other niceties. Full list below.</p>
                </span>
            </section>

            <h5 id=jquery-simple-interfaces>Simple Interfaces</h5>

            <section class=row>
                <span class=span16>

                    <p>Most of the simple interfaces are relate to value-based or
                    toggle-like properties.</p>

                    <p><span class="label warning">0.3.2</span> The <code>css</code>
                    interface has been renamed to <code>class</code> and demoted to
                    a simple interface. As a result, the <code>style</code>
                    interface has been renamed to <code>css</code> for consistency
                    with jQuery and Zepto.</p>

                    <table id=ex2>
                        <tbody>
                            <tr>
                                <td><code>text</code></td>
                                <td><input type=text value="Hello World!"></td>
                                <td><span></span></td>
                            </tr>
                            <tr>
                                <td><code>html</code></td>
                                <td><input type=text value="<strong>Hello World!</strong>"></td>
                                <td><span></span></td>
                            </tr>
                            <tr>
                                <td><code>value</code></td>
                                <td><input type=text value="Hello World!"></td>
                                <td><input type=text></td>
                            </tr>
                            <tr>
                                <td><code>enabled</code></td>
                                <td><input type=checkbox></td>
                                <td><input type=text></td>
                            </tr>
                            <tr>
                                <td><code>disabled</code></td>
                                <td><input type=checkbox checked></td>
                                <td><input type=text></td>
                            </tr>
                            <tr>
                                <td><code>checked</code></td>
                                <td><input type=checkbox></td>
                                <td><input type=checkbox></td>
                            </tr>
                            <tr>
                                <td><code>visible</code></td>
                                <td><input type=checkbox checked></td>
                                <td><input type=text></td>
                            </tr>
                            <tr>
                                <td><code>hidden</code></td>
                                <td><input type=checkbox></td>
                                <td><input type=text></td>
                            </tr>
                            <tr>
                                <td><code>class</code></td>
                                <td><input class=span3 type=text value="btn primary"><br>
                                    <em>e.g. btn primary, label success, alert-message error</em></td>
                                <td><span>new!</span></td>
                            </tr>

                        </tbody>
                    </table>
                </span>
            </section>

            <h5 id=jquery-compound-interfaces>Compound Interfaces</h5>

            <section class=row>
                <span class=span16>
                    <p><span class="label warning">0.3.2</span> The <code>css</code>
                    interface has been renamed to <code>class</code> and demoted to
                    a simple interface. As a result, the <code>style</code>
                    interface has been renamed to <code>css</code> for consistency
                    with jQuery and Zepto.</p>

                    <p><span class="label warning">0.3</span> Breaking change, the delimiter
                    between compond interface keys is now a period (.) rather than
                    a colon (:). This mentally maps better to it's multi-method/property
                    traversal on the object.</p>

                    <p>Compound intefaces map more directly to the underlying object API
                    and exposes more granular control.</p>

                    <p>Compound interface identifiers are delimited by a period (.). The
                    first key is the <em>reference</em> interface and typically maps to
                    a method on the object in which it itself takes a key (thus being
                    compound).</p>

                    <table id=ex3>
                        <tbody>
                            <tr>
                                <td><code>prop.value</code></td>
                                <td><input type=text value="Hello World!"></td>
                                <td><input type=text></td>
                            </tr>
                            <tr>
                                <td><code>attr.href</code></td>
                                <td><input type=text value="http://example.com"></td>
                                <td><a href="#">Variable Link</a></td>
                            </tr>
                            <tr>
                                <td><code>css.color</code></td>
                                <td><input type=text value="red"></td>
                                <td><strong>Color</strong></td>
                            </tr>
                            <tr>
                                <td><code>data.role</code></td>
                                <td><input type=text value="nothing"></td>
                                <td><span>Nothing to show, but for the curious
                                    open up the console and type
                                    <code>document.ex3.data('role')</code></span>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </span>
            </section>

            <h3 id=zepto>Zepto</h3>

            <section class=row>
                <span class=span16>
                    <p><strong>Supported Type.</strong> Zepto arrays, CSS selectors,
                    and DOM elements.</p>

                    <p><strong>Events.</strong> DOM events via Zepto's <code>bind</code>,
                    <code>unbind</code>, and <code>trigger</code> methods</p>

                    <p><strong>Interfaces.</strong> The Zepto hook implements the
                    same interfaces as the jQuery hook with the exception of the
                    <code>prop.&lt;key&gt;</code> compound interface since Zepto
                    does not differentiate between properties and attributes in
                    the API.</p>
                </span>
            </section>

            <h3 id=backbone-view>Backbone View</h3>

            <section class=row>
                <span class=span16>
                    <p><strong>Supported Type.</strong> <code>Backbone.View</code>
                    objects</p>

                    <p><strong>Events.</strong> Similar to the jQuery hook under the
                    hood, therefore using the DOM events mentioned above.</p>

                    <p><strong>Interfaces.</strong> Similar to the jQuery hook under the
                    hood, therefore all interfaces above work for these objects. In
                    addition, interface identifier that reference a method name on
                    the <code>Backbone.View</code> object directly may be used. Note,
                    this will take precedence over the above jQuery interfaces of the
                    same name.</p>
                </span>
            </section>

            <h3 id=backbone-model>Backbone Model</h3>

            <section class=row>
                <span class=span16>
                    <p><strong>Supported Type.</strong> <code>Backbone.Model</code>
                    objects</p>

                    <p><strong>Events.</strong> Uses the built-in event system Backbone
                    provides.</p>

                    <p><strong>Interfaces.</strong> Similar to the plain objects
                    above, the interface identifiers correspond to properties and
                    methods. Under the hood, getting and setting the properties
                    will be done via the object's native <code>get</code> and
                    <code>set</code> methods (this ensures when a property is
                    set, the change events fire).</p>
                </span>
            </section>

        </div>

        <script>var require = { baseUrl: 'js/' };</script>
        <script src="js/underscore.js"></script>
        <script src="js/require.js"></script>
        <script src="js/prettify.js"></script>
        <script src="js/docs.js"></script>
    </body>
</html>

